---
title: "AEM303 ANLY"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    includes: 
        after_body: "busy.html"
runtime: shiny
---

<style type="text/css">

    .storyboard-nav .sbframelist {
        margin: 0 auto;
        width: 94%;
        height: 70px;
        overflow: hidden;
        text-shadow: none;
        margin-bottom: 8px;
    }

    .storyboard-nav .sbnext, .storyboard-nav .sbprev {
        float: left;
        width: 2%;
        height: 50px;
        font-size: 50px;
    }

    body {
      padding-top:0px
    }
    
    .navbar{
      visibility: hidden
    }

</style>

```{r setup, include = FALSE}
library(leaflet)
library(shiny)
library(shinyjs)
library(flexdashboard)
library(plotly)
library(shinycssloaders)
library(shinyWidgets)
library(dplyr)
library(stringr)
library(RColorBrewer)
library(htmlwidgets)
library(gam)
library(rpart)
library(rattle)
library(tree)
library(caret)
library(visNetwork)
library(sparkline)
library(shinyLP)

filter <- dplyr::filter

map_data <- readRDS('map_data.rds')
map_data_df <- as.data.frame(map_data)
superfund_data <- readRDS('superfund_data.rds')
pp_data <- readRDS('pp_data.rds')
#popup_dat <- readRDS('popup_cancer.rds')

# superfund color schemes
bins_sites <- c(0, 1, 2, 3, 4, 5,6, 10, 15,  Inf)
pal_sites <- colorBin("YlOrRd", domain = map_data$num_sites, bins = bins_sites)

bins_score <- c(0, 20, 40, 60, 80, 100, 200, 400,  Inf)
pal_score <- colorBin("YlOrRd", domain = map_data$sum_site_score, bins = bins_score)

# cancer color scheme
bins_cancer <- c(217,379,411,432,448,461,474,489,510,Inf)
pal_cancer <- colorBin("YlOrRd", map_data$cancer_per100k, bins = bins_cancer)

# pp color schemes
bins_pp <- c(0, 1,2, 5, 12, 25, 36, 51, Inf)
pal_pp <- colorBin("YlOrRd", domain = map_data$num_pp, bins = bins_pp)
bins_pp_mw <- c(0,1,50,150, 960, 1580, 2300, 2900, 5000, Inf)
pal_pp_mw <- colorBin("YlOrRd", domain = map_data$sum_capacity_mw, bins = bins_pp_mw)

# setup variables for the maps (mostly pp)
react_list <- reactiveValues(pp_num_type = "num_pp",pp_capacity_type = "sum_capacity_mw",pp_pal = pal_pp,pp_pal_mw = pal_pp_mw, pp_data = pp_data)
react_list$num_traces_plotly_cancer = 0
react_list$num = 25

react_list$cancer_var_x = "sum_site_score"
react_list$cancer_var_y = "cancer_per100k"

react_list$plotly_plot_made <- FALSE

react_list$data_show <- map_data_df

k <- 3
polygon_data_num <- map_data[["num_pp"]]
polygon_data_capacity <- map_data@data[["sum_capacity_mw"]]
pal_num <- pal_pp
pal_mw <- pal_pp_mw
pp_data_map <- pp_data
capacity_variable <- "sum_capacity_mw"

react_list$mse <- ""
```

### Intro: Heatmap of Cancer Rates by County {data-commentary-width=500}

```{r, eval = TRUE}

fillRow(leafletOutput("intro_map"))


output$intro_map <- renderLeaflet({
  leaflet(data = map_data) %>%
  # Base groups
  addTiles() %>%
  setView(lng = -105, lat = 40, zoom = 4) %>% 
  addPolygons(fillColor = ~pal_cancer(cancer_per100k), 
              fillOpacity = 0.8, 
              color = "#BDBDC3", 
              weight = 1,
              layerId = ~GEOID,
              group="Cancer Rate/100k") %>% 
    addLegend(position = "bottomright",
                pal = pal_cancer,
                values  = map_data$cancer_per100k,
                group = "Cancer Rate/100k",
                title = "Cancer Rate/100k",
                layerId = "cancer_legend",
                labFormat = labelFormat(digits=1))
})



# observeEvent(input$intro_map_click, {
# 
#     click <- input$intro_map_click
#     text<-paste("Latitude ", round(click$lat,2), "Longtitude ", round(click$lng,2))
# 
#     proxy <- leafletProxy("intro_map")
# 
#     ## This displays the pin drop circle
#     proxy %>% 
#         clearGroup("new_point") %>%
#         #clearMarkers(layerId=input$mymap_click$id) %>%
#         #addPopups(click$lng, click$lat) %>%
#         addCircles(click$lng, click$lat, radius=30000, color="blue", group = "new_point")
# 
# })

observeEvent(input$go_worst10, {
    message(paste("intro map: Click on worst ranking. Number selected=",react_list$num,"~~",Sys.time()))
    worst_5 <- map_data_df %>% dplyr::arrange(desc(cancer_per100k)) %>% head(react_list$num)
    worst_5['order'] <- 1:nrow(worst_5)
    #text<-paste("Latitude ", round(worst_5$lat,2), "Longtitude ", round(worst_5$lng,2))

    proxy <- leafletProxy("intro_map")

    ## This displays the pin drop circle
    proxy %>% 
        clearGroup("worst_points") %>%
        addCircles(worst_5$longitude, worst_5$latitude, radius=50000, color="blue", group = "worst_points", 
                   popup = paste0("<strong>County: </strong>", 
                                                    worst_5$county, ", ", worst_5$state, 
                                                    "<br><strong>Cancer/100k: </strong>", 
                                                    worst_5$cancer_per100k,
                                                    "<br><strong>Rank: </strong> ",worst_5$order))

})

observeEvent(input$go_best10, {
    message(paste("intro map: Click on best ranking. Number selected=",react_list$num,"~~",Sys.time()))
    best5 <- map_data_df %>% dplyr::arrange(cancer_per100k) %>% head(react_list$num)
    best5['order'] <- 1:nrow(best5)
    #text<-paste("Latitude ", round(worst_5$lat,2), "Longtitude ", round(worst_5$lng,2))

    proxy <- leafletProxy("intro_map")

    ## This displays the pin drop circle
    proxy %>% 
        clearGroup("best_points") %>%
        addCircles(best5$longitude, best5$latitude, radius=50000, color="green", group = "best_points", 
                   popup = paste0("<strong>County: </strong>", 
                                                    best5$county, ", ", best5$state, 
                                                    "<br><strong>Cancer/100k: </strong>", 
                                                    best5$cancer_per100k,
                                                    "<br><strong>Rank: </strong> ",best5$order))

})
radius = 3
# When circle is clicked on...show a popup
observeEvent(input$intro_map_shape_click$id, {
    
    pointId <- input$intro_map_shape_click$id
    shape_i = map_data_df %>% filter(GEOID == pointId)
    offset = isolate((input$intro_map_bounds$north - input$intro_map_bounds$south) / (23 + radius + (18 - input$intro_map_zoom)^2 ))
    message(paste("Click on intro map. ",shape_i$county,", ",shape_i$state,"~~",Sys.time()))
    
    leafletProxy("intro_map") %>% addPopups(lat = shape_i$latitude + offset, lng = shape_i$longitude, 
                                                    paste0("<strong>County: </strong>", 
                                                    shape_i$county, ", ", shape_i$state, 
                                                    "<br><strong>Cancer/100k: </strong>", 
                                                    shape_i$cancer_per100k))
  })


observeEvent(input$best_popup, {
    message(paste("intro map: Click on best ranking popup. Number selected=",react_list$num,"~~",Sys.time()))
    leafletProxy("intro_map") %>%
    clearPopups()
    best <- map_data_df %>% dplyr::arrange(desc(cancer_per100k)) %>% head(react_list$num)
    best['order'] <- 1:nrow(best)
    best <- best %>% arrange(desc(order))
    offset = isolate((input$intro_map_bounds$north - input$intro_map_bounds$south) / (23 + radius*1.8 + (18 - input$intro_map_zoom)^2 ))

    #shape_i <- best[react_list$num,]
    leafletProxy("intro_map") %>% addPopups(lat = best$latitude + offset, lng = best$longitude, 
                                                  paste0("<strong>County: </strong>", 
                                                  best$county, ", ", best$state, 
                                                  "<br><strong>Cancer/100k: </strong>", 
                                                  best$cancer_per100k,
                                                    "<br><strong>Rank: </strong> ",best$order))

    #react_list$num <- react_list$num + 1
  })

observeEvent(input$worst_popup, {
    message(paste("intro map: Click on best ranking popup. Number selected=",react_list$num,"~~",Sys.time()))
    leafletProxy("intro_map") %>%
    clearPopups()
    worst <- map_data_df %>% dplyr::arrange(cancer_per100k) %>% head(react_list$num)
    worst['order'] <- 1:nrow(worst)
    worst <- worst %>% arrange(desc(order))
    offset = isolate((input$intro_map_bounds$north - input$intro_map_bounds$south) / (23 + radius*1.8 + (18 - input$intro_map_zoom)^2 ))

    #shape_i <- best[react_list$num,]
    leafletProxy("intro_map") %>% addPopups(lat = worst$latitude + offset, lng = worst$longitude, 
                                                  paste0("<strong>County: </strong>", 
                                                  worst$county, ", ", worst$state, 
                                                  "<br><strong>Cancer/100k: </strong>", 
                                                  worst$cancer_per100k,
                                                    "<br><strong>Rank: </strong> ",worst$order))

    #react_list$num <- react_list$num + 1
  })
```


```{r}
# TRIED TO GET POPUPS TO COME UP ONE AT A TIME
# observe({
#     req(!is.null(react_list$num))
#     req(react_list$num <= 10 & react_list$num >= 2)
#     
#     best <- map_data_df %>% dplyr::arrange(desc(cancer_per100k)) %>% head(num)
#       offset = isolate((input$intro_map_bounds$north - input$intro_map_bounds$south) / (23 + radius*1.5 + (18 - input$intro_map_zoom)^2 ))
#   
#       shape_i <- best[react_list$num,]
#       leafletProxy("intro_map") %>% addPopups(lat = shape_i$latitude + offset, lng = shape_i$longitude, 
#                                                     paste0(shape_i$county, 
#                                                     ": ", 
#                                                     shape_i$cancer_per100k))
#       
#       react_list$num <- react_list$num + 1
#       
# })

observeEvent(input$clear_intro_map,{
  leafletProxy("intro_map") %>%
    clearPopups()
  leafletProxy("intro_map")  %>% 
        clearGroup("best_points")
  leafletProxy("intro_map")  %>% 
        clearGroup("worst_points")
  react_list$num <- input$num_intro
  message(paste("intro map: reset map~~",Sys.time()))
})
```

***

This project investigates factors affecting county-level cancer rates around the United States. Many factors contribute to cancer rates, including biological, occupational risk, lifestyle, and environmental causes. This story will focus on how environmental contamination from toxic waste sites and powerplants are correlated with cancer rates. 

Start off by <u>clicking</u> on a few counties on the heatmap to get yourself familiar with the NIH data for age-adjusted cancer rates. In subsequent frames, more variables will be introduced.

Let’s examine the distribution of cancer rates around the country. 

* To see the rankings for 25 highest and 25 lowest cancer rate counties on the map, <u>click the buttons (highest/lowest rate counties) below</u> . 
* To show popups for location, cancer rate, and rank for the highest or lowest counties in the US, <u>click on the (highest/lowest counties info) buttons</u>.
* To change the size of rankings and re-display the results, <u>use the arrows below or enter a number</u> into the field to change the size of the rankings, then <u>click</u> "Reset Map", then <u>click</u> the highest/lowest buttons to see the new rankings. You must reset the map for number selection to be reflected when clicking on the rankings.

```{r}
fluidRow(actionButton("go_worst10", "Highest rate counties"),
actionButton("go_best10", "Lowest rate counties"),align="center")
```

<hr style="height:5px; visibility:hidden;" />

```{r}
fluidRow(actionButton("best_popup", "Highest counties info"),
         actionButton("worst_popup", "Lowest counties info"),align="center")
```

<hr style="height:5px; visibility:hidden;" />

```{r}
fluidRow(div(style="display: inline-block;vertical-align:top; width: 150px;",numericInput("num_intro", NULL, value = 25, min = 1, max = 100, step = 1, width = '100%')),div(style="display: inline-block;vertical-align:top; width: 200px;",actionButton("clear_intro_map", "Reset Map")),align="center")
```

The West and Southwest have many counties with the lowest cancer rates. Higher cancer rate counties are often found in the South, particularly in Kentucky. The most interesting contrast between the best and worst counties appears near the tri-cities region in southwest Virginia. Kentucky counties are experiencing the highest cancer rates, while their Virginia neighbors have the lowest rates in the country.

Navigate through the storyboards for this project by <u>clicking on the arrows in the top left</u>. If things get cut off at the bottom, try <u>zooming out</u> using `CTRL` + `-` (CTRL key and Minus Key) or going into fullscreen by <u>clicking F11</u>

### Distribution of Cancer Rates by US Regions {data-commentary-width=500}

```{r}
plotlyOutput("plotly_cancer_dist")
output$plotly_cancer_dist <- renderPlotly({
  message(paste("dist_plot: inputs selected: exclude_states:[",paste(input$exclude_state_dist_us, collapse = ","),"], breakdown:",input$dist_level_us,", y variable:",input$dist_y_var),"~~",Sys.time())
  map_data_df_dist <- map_data_df %>% dplyr::filter(!state %in% input$exclude_state_dist_us)
  map_data_df_dist <- map_data_df_dist[!is.na(input$dist_y_var),]

  plot_ly(
          x = map_data_df_dist[[input$dist_level_us]], 
          y = map_data_df_dist[[input$dist_y_var]], 
          color = map_data_df_dist[[input$dist_level_us]], 
          type = "box", 
          boxpoints = "all", 
          jitter = 0.4,
          pointpos = -2,
          #hoverinfo = "text",
          text = paste0("<b>County: </b>", map_data_df_dist$county,", ",map_data_df_dist$state,
                            "<br><b>Cancer/100k: </b>",map_data_df_dist$cancer_per100k,
                            "<br><b>Avg. Annual #: </b>",map_data_df_dist$avg_annual_count,
                            "<br><b>Recent Trend: </b>",map_data_df_dist$recent_trend))
    })

# data = map_data_df %>% mutate(cancer_pCI = cancer_95ciH - cancer_per100k, cancer_mCI = cancer_per100k - cancer_95ciL) %>% filter(!is.na(cancer_per100k)) %>% arrange(cancer_per100k)
# data <- data %>% mutate(order = 1:nrow(data))
# plot_ly(data = data,
#         x = ~order,
#         y = ~cancer_per100k,
#         error_y = list(array = ~cancer_pCI),
#         type = 'scatter',
#         mode = 'markers'
# )

```

***

As the heatmap on the previous board showed, there are clear variations in cancer rates across the United States. 

* Examine the distribution of cancer rates further by <u>selecting the administrative breakdown type</u> of your choice from the "Select Breakdown Type" box. 
* To see the individual county info and the box plot quantile values, <u>hover your mouse over the dots or the box</u>.
* To get a closer look, <u>click and drag</u> on the graph to zoom in on the plot. 
* This study focuses on cancer rate, but you can also view the distribution of alternative cancer statistics by <u>selecting a different cancer variable</u> from the "Select Cancer Variable" box*.

```{r}

selectInput("dist_level_us","Select Breakdown Type",list("Census Region (4)" = "region",
                                                           "Census Division (9)" = "division",
                                                           "EPA Region (10)" = "epa_region",
                                                           "States" = "state"), selected = "Census Region (4)")

selectInput("dist_y_var","Select Cancer Variable",list("Cancer Rate per 100k" = "cancer_per100k",
                                                           "Five year trend" = "trend5yr",
                                                           "Average annual count" = "avg_annual_count"), selected = "cancer_per100k")
```

For Census Regions, the distribution of cancer rates in the West are the lowest. What if we exclude some of the worst or best states from the distribution? For example, there was a stark difference between counties on the border between Kentucky and Virginia. 

* Try <u>selecting Kentucky</u> on the "Exclude US States" box to see how removing a state's counties affects the distributions. Try <u>selecting more than one state</u> to see the effects. <u>Flip</u> back and forth between this and the previous board to pick out high or low cancer rate states to see the effect of removing them from the box plots.

```{r}
#tags$style(type='text/css', ".selectize-dropdown-content {max-height: 200px; }")
pickerInput("exclude_state_dist_us","Exclude US States",
  choices = list('Alabama' = 'AL', 
  'Alaska' = 'AK',
  'Arizona' = 'AZ',
  'Arkansas' = 'AR',
  'California' = 'CA',
  'Colorado' = 'CO',
  'Connecticut' = 'CT',
  'District of Columbia' = 'DC',
  'Delaware' = 'DE',
  'Florida' = 'FL',
  'Georgia' = 'GA',
  'Hawaii' = 'HI',
  'Idaho' = 'ID',
  'Illinois' = 'IL',
  'Indiana' = 'IN',
  'Iowa' = 'IA',
  'Kentucky' = 'KY',
  'Louisiana' = 'LA',
  'Maine' = 'ME',
  'Maryland' = 'MD',
  'Massachusetts' = 'MA',
  'Michigan' = 'MI',
  'Mississippi' = 'MS',
  'Missouri' = 'MO',
  'Montana' = 'MT',
  'Nebraska' = 'NE',
  'New Hampshire' = 'NH',
  'New Jersey' = 'NJ',
  'New Mexico' = 'NM',
  'New York' = 'NY',
  'Nevada' = 'NV',
  'North Carolina' = 'NC',
  'North Dakota' = 'ND',
  'Ohio' = 'OH',
  'Oklahoma' = 'OK',
  'Oregon' = 'OR',
  'Pennsylvania' = 'PA',
  'Rhode Island' = 'RI',
  'South Carolina' = 'SC',
  'South Dakota' = 'SD',
  'Tennessee' = 'TN',
  'Texas' = 'TX',
  'Utah' = 'UT',
  'Virginia' = 'VA',
  'Vermont' = 'VT',
  'Washington' = 'WA',
  'West Virginia' = 'WV',
  'Wisconsin' = 'WI',
  'Wyoming' = 'WY'), options = list(`actions-box` = TRUE,`size` = 8),multiple = T)
```

*Note if the plotly plot does not fill the white space, try zooming in and out in your browser, refreshing the page, or using a different browser.
 
### Superfund Sites: <br> Contamination Across the US {data-commentary-width=400}

```{r}

leafletOutput("sf_map")

output$sf_map <- renderLeaflet({
  message(paste("superfund map: map loaded~~",Sys.time()))
  leaflet() %>%
  # Base groups
  addTiles() %>%
  setView(lng = -105, lat = 40, zoom = 4)  %>%
  addPolygons(data=map_data,
              fillColor = ~pal_sites(num_sites),
              fillOpacity = 0.8,
              color = "#BDBDC3",
              weight = 1,
              layerId = ~GEOID,
              group="# of Superfund Sites",
              popup=paste0("<strong>Location: </strong>", 
                          map_data$county,", ",map_data$state,
                          "<br><strong># of Superfund Sites: </strong>", 
                          map_data$num_sites,
                          "<br><strong>Summed Site Score: </strong>", 
                          map_data$sum_site_score)
              ) %>% 
  addPolygons(data=map_data,
              fillColor = ~pal_score(sum_site_score),
              fillOpacity = 0.8,
              color = "#BDBDC3",
              weight = 1,
              layerId = ~paste(GEOID,'_s'),
              group="Summed Site Score",
              popup=paste0("<strong>Location: </strong>", 
                          map_data$county,", ",map_data$state,
                          "<br><strong># of Superfund Sites: </strong>", 
                          map_data$num_sites,
                          "<br><strong>Summed Site Score: </strong>", 
                          map_data$sum_site_score)
              ) %>% 
  addPolygons(data = map_data,
              fillColor = ~pal_cancer(cancer_per100k), 
              fillOpacity = 0.8, 
              color = "#BDBDC3", 
              weight = 1,
              layerId = ~paste(GEOID,'_C'),
              popup = paste0("<strong>County: </strong>", map_data$county,", ",map_data$state,
                            "<br><strong>Cancer/100k: </strong>",map_data$cancer_per100k,
                            "<br><strong>Avg. Annual #: </strong>",map_data$avg_annual_count,
                            "<br><strong>Recent Trend: </strong>",map_data$recent_trend),
              group="Cancer Rate/100k")%>% 
  addMarkers(data=superfund_data,
             lat=superfund_data[['latitude']], 
             lng=superfund_data[['longitude']], 
             popup=paste0("<strong>Name: </strong>", 
                          superfund_data$`Site Name`,
                          "<br><strong>Location: </strong>", 
                          superfund_data$county,", ",superfund_data$state,
                          "<br><strong>Site Score: </strong>", 
                          superfund_data$site_score, 
                          "<br><strong>Listing Year: </strong>", 
                          superfund_data$listing_year),
             group = "Superfund Site Markers",
             icon = list(
                iconUrl = 'skull-2-icon.png',
                iconSize = c(48, 48)
              ),
             clusterOptions = markerClusterOptions()) %>% 

  addLayersControl(
    position = c('topright'),
    baseGroups = c("# of Superfund Sites","Summed Site Score","Cancer Rate/100k"), #overlayGroups = c("Cancer Rate/100,000 by Counties","Number of Superfund Sites"),
    overlayGroups = c("Superfund Site Markers"),
    options = layersControlOptions(collapsed = FALSE)
  )
})

observeEvent(input$sf_map_groups,{
  
  leafletProxy('sf_map') %>% removeControl(layerId = "site_legend") %>% removeControl(layerId = "score_legend") %>% removeControl(layerId = "cancer_legend")
  
  if ("Cancer Rate/100k" %in% isolate(input$sf_map_groups)){
    message(paste("superfund map: heatmap changed to cancer rate~~",Sys.time()))
    leafletProxy('sf_map') %>% addLegend(position = "bottomright",
                                                pal = pal_cancer,
                                                values  = map_data$cancer_per100k,
                                                group = "Cancer Rate/100k",
                                                title = "Cancer Rate/100k",
                                                layerId = "cancer_legend",
                                                labFormat = labelFormat(digits=1))
  }
  else if ("# of Superfund Sites" %in% isolate(input$sf_map_groups)){
    message(paste("superfund map: heatmap changed to # superfund sites~~",Sys.time()))
    leafletProxy('sf_map') %>% addLegend(position = "bottomright",
                                                pal = pal_sites,
                                                values  = map_data$num_sites,
                                                group = "# of Superfund Sites",
                                                title = "# of Superfund Sites",
                                                layerId = "site_legend",
                                                labFormat = labelFormat(digits=1))
  }
  else if ("Summed Site Score" %in% isolate(input$sf_map_groups)){
    message(paste("superfund map: heatmap changed to summed site score~~",Sys.time()))
    leafletProxy('sf_map') %>% addLegend(position = "bottomright",
                                                pal = pal_score,
                                                values  = map_data[['sum_site_score']],
                                                group = "Summed Site Score",
                                                title = "Summed Site Score",
                                                layerId = "score_legend",
                                                labFormat = labelFormat(digits=1))
  }
})

observeEvent(input$sf_map_shape_click$id, {
  message(paste("superfund map: map click on shape:,",input$sf_map_shape_click$id,"~~",Sys.time()))
})
```


***

Locations of environmental contamination that the Environmental Protection Agency (EPA) determines as toxic enough are designated Superfund sites. The EPA then works to cleanup the area at the expense of the offending group and, increasingly, at taxpayers' expense. The site score increases 0 to 100 as the degree of hazard increases. Sites are removed from the list once they are cleaned up. Sites have to be added to the list, and sometimes that can take a while. Only sites that were added to the list before July 2014 are included on this map. The site scores are summed to the county level to show the broad environmental hazard for that county.

Use the map on this storyboard to find out the locations of Superfund sites and their site scores around the United States. The skull markers indicate a Superfund site. 

* See information for individual superfund sites or counties by <u> clicking on them</u>. Counties missing the cancer rate variable appear as grey on the heatmap. If there are many markers in an area of the map, they will be clustered into a circle with a number. To uncluster them, <u>click on the number</u> or <u>scroll with your mouse wheel</u> to zoom in where there are fewer in that area.
* Visually compare the relationship between summed superfund site scores by county, number of sites, and cancer rates by changing the heatmap with the <u>radio buttons on the top right of the map</u> 
* To show/hide the location of individual superfund sites, <u>check/uncheck the "Superfund Site Markers" box</u>. 

While many of California's cancer rates are not following the severity of superfund sites, the Mid-Atlantic (New Jersey, Pennsylvania, and New York) show high level of cancer rates and many superfund sites with high scores. Louisiana also has few superfund sites, but their cancer rates are some of the highest.


### Powerplants by Energy Production Type {data-commentary-width=500}

```{r}

observeEvent({input$clear_powerplant_map},{
            message(paste("pp map: data changed to powerplant type [",input$choose_plant_type,"]~~",Sys.time()))
             if (input$choose_plant_type == "All"){
               react_list$pp_num_type = "num_pp"
               react_list$pp_capacity_type = "sum_capacity_mw"
               react_list$pp_pal = pal_pp
               react_list$pp_data = pp_data
             }
             else if (input$choose_plant_type == "Renewable"){
               react_list$pp_num_type = "pp_renewable"
               react_list$pp_capacity_type = "capacity_mw_renewable"
               bins_pp_mw <- c(0,1,50,150, 960, 1580, 2300, 2900, 5000, Inf)
               react_list$pp_pal = colorBin("YlOrRd", domain = map_data[[react_list$pp_num_type]], bins = bins_pp)
               react_list$pp_pal_mw = colorBin("YlOrRd", domain = map_data[[react_list$pp_capacity_type]], bins = bins_pp_mw)
               react_list$pp_data = pp_data %>% dplyr::filter(primary_fuel %in% c("Geothermal","Hydro","Nuclear","Solar","Wind","Bioass"))
             }
             else if (input$choose_plant_type == "Carbon"){
               react_list$pp_num_type = "pp_carbon"
               react_list$pp_capacity_type = "capacity_mw_carbon"
               bins_pp_mw <- c(0,1,50,150, 960, 1580, 2300, 2900, 5000, Inf)
               react_list$pp_pal = colorBin("YlOrRd", domain = map_data[[react_list$pp_num_type]], bins = bins_pp)
               react_list$pp_pal_mw = colorBin("YlOrRd", domain = map_data[[react_list$pp_capacity_type]], bins_pp_mw)
               react_list$pp_data = pp_data %>% dplyr::filter(primary_fuel %in% c("Coal","Gas","Oil","Petcoke"))
             }
             else{
               react_list$pp_num_type = paste0("pp_",str_to_lower(input$choose_plant_type))
               react_list$pp_capacity_type = paste0("capacity_mw_",str_to_lower(input$choose_plant_type))
               react_list$pp_pal = colorBin("YlOrRd", domain = map_data[[react_list$pp_num_type]], bins = bins_pp)
               react_list$pp_pal_mw = colorBin("YlOrRd", domain = map_data[[react_list$pp_capacity_type]])
               react_list$pp_data = pp_data %>% dplyr::filter(primary_fuel == input$choose_plant_type)
             }
})

leafletOutput("pp_map")





output$pp_map <- renderLeaflet({

  polygon_data_num <- map_data[[react_list$pp_num_type]]
  polygon_data_capacity <- map_data@data[[react_list$pp_capacity_type]]
  pal_num <- react_list$pp_pal
  pal_mw <- react_list$pp_pal_mw
  pp_data_map <- react_list$pp_data
  capacity_variable <- react_list$pp_capacity_type
  message(nrow(react_list$pp_data))
  
        
  energyIcons <- icons(
  iconUrl = case_when(pp_data_map$primary_fuel ==  "Coal" ~   "coal.png",
                      pp_data_map$primary_fuel ==  "Gas" ~   "gas.png",
                      pp_data_map$primary_fuel ==  "Geothermal" ~   "geothermal.png",
                      pp_data_map$primary_fuel ==  "Hydro" ~   "hydro.png",
                      pp_data_map$primary_fuel ==  "Nuclear" ~   "nuclear.png",
                      pp_data_map$primary_fuel ==  "Oil" ~   "oil.png",
                      pp_data_map$primary_fuel ==  "Solar" ~   "solar.png",
                      pp_data_map$primary_fuel ==  "Waste" ~   "waste.png",
                      pp_data_map$primary_fuel ==  "Wind" ~   "wind.png",
                      pp_data_map$primary_fuel ==  "Biomass" ~   "biomass.png",
                      TRUE ~ "all_other.png"
                      
  ),
  iconWidth = 48, iconHeight = 48,
  iconAnchorX = 24, iconAnchorY = 20,
  popupAnchorX = 0, popupAnchorY = 48
  )
  
  
  leaflet() %>%
  # Base groups
  addTiles() %>%
  setView(lng = -105, lat = 40, zoom = 4)  %>%
  addPolygons(data=map_data,
              fillColor = ~pal_num(polygon_data_num),
              fillOpacity = 0.8,
              color = "#BDBDC3",
              weight = 1,
              layerId = ~GEOID,
              group="# of Powerplants",
              popup=paste0("<strong>Location: </strong>", 
                          map_data$county,", ",map_data$state,
                          "<br><strong># of Powerplants: </strong>", 
                          polygon_data_num,
                          "<br><strong>Total Capacity (MW): </strong>", 
                          polygon_data_capacity)
              ) %>% 
  addPolygons(data=map_data,
              fillColor = ~pal_mw(polygon_data_capacity),
              fillOpacity = 0.8,
              color = "#BDBDC3",
              weight = 1,
              layerId = ~paste(GEOID,'_1'),
              group="Capacity (MW)",
              popup=paste0("<strong>Location: </strong>", 
                          map_data$county,", ",map_data$state,
                          "<br><strong># of Powerplants: </strong>", 
                          polygon_data_num,
                          "<br><strong>Total Capacity (MW): </strong>", 
                          polygon_data_capacity)
              ) %>% 
  addPolygons(data = map_data,
              fillColor = ~pal_cancer(cancer_per100k), 
              fillOpacity = 0.8, 
              color = "#BDBDC3", 
              weight = 1,
              layerId = ~paste(GEOID,'_C'),
              popup = paste0("<strong>County: </strong>", map_data$county,", ",map_data$state,
                            "<br><strong>Cancer/100k: </strong>",map_data$cancer_per100k,
                            "<br><strong>Avg. Annual #: </strong>",map_data$avg_annual_count,
                            "<br><strong>Recent Trend: </strong>",map_data$recent_trend),
              group="Cancer Rate/100k")%>% 
  addMarkers(data=pp_data_map,
             lat=pp_data_map[['latitude']], 
             lng=pp_data_map[['longitude']], 
             icon = energyIcons,
             popup=paste0("<strong>Name: </strong>", 
                          pp_data_map$name,
                          "<br><strong>Location: </strong>", 
                          pp_data_map$county,", ",pp_data_map$state,
                          "<br><strong>Fuel Type: </strong>", 
                          pp_data_map$primary_fuel, 
                          "<br><strong>Capacity MW: </strong>", 
                          pp_data_map$capacity_mw,
                          "<br><strong>'13-'17 Yearly Generation (GW):  </strong>",round(pp_data_map$generation_gwh_avg,2),
                    "<br><strong>Commissioning Year: </strong>", pp_data_map$commissioning_year),
             #popupOptions = popupOptions(offset = list(c(0,10)))
             group = "Powerplant Markers",
             
             clusterOptions = markerClusterOptions()) %>% 

  addLayersControl(
    position = c('topright'),
    baseGroups = c("# of Powerplants","Capacity (MW)","Cancer Rate/100k"), #overlayGroups = c("Cancer Rate/100,000 by Counties","Number of Superfund Sites"),
    overlayGroups = c("Powerplant Markers"),
    options = layersControlOptions(collapsed = FALSE)
  )
})

observeEvent(input$pp_map_groups,{
  leafletProxy('pp_map') %>% removeControl(layerId = "pp_legend") %>% removeControl(layerId = "capacity_legend") %>% removeControl(layerId = "cancer_legend")
  
  if ("Cancer Rate/100k" %in% isolate(input$pp_map_groups)){
    message(paste("pp map: heatmap changed to cancer rate~~",Sys.time()))
    leafletProxy('pp_map') %>% addLegend(position = "bottomright",
                                                pal = pal_cancer,
                                                values  = map_data$cancer_per100k,
                                                group = "Cancer Rate/100k",
                                                title = "Cancer Rate/100k",
                                                layerId = "cancer_legend",
                                                labFormat = labelFormat(digits=1))
  }
  else if ("# of Powerplants" %in% isolate(input$pp_map_groups)){
    message(paste("pp map: heatmap changed to # of pp~~",Sys.time()))
    leafletProxy('pp_map') %>% addLegend(position = "bottomright",
                                                pal = pal_num,
                                                values  = polygon_data_num,
                                                group = "# of Powerplants",
                                                title = "# of Powerplants",
                                                layerId = "pp_legend",
                                                labFormat = labelFormat(digits=1))
  }
  else if ("Capacity (MW)" %in% isolate(input$pp_map_groups)){
    message(paste("pp map: heatmap changed to capacity~~",Sys.time()))
    leafletProxy('pp_map') %>% addLegend(position = "bottomright",
                                                pal = pal_mw,
                                                values  = polygon_data_capacity,
                                                group = "Capacity (MW)",
                                                title = "Capacity (MW)",
                                                layerId = "capacity_legend",
                                      
                                         
                                                   labFormat = labelFormat(digits=1))
  }
})

observeEvent(input$pp_map_shape_click$id, {
  message(paste("superfund map: map click on shape:,",input$pp_map_shape_click$id,"~~",Sys.time()))
})
```


***
Carbon-based powerplants release more emissions than renewable powerplants. For the purpose of finding links to cancer rates, it is important to see where the worst emitting powerplants are located in the United States. You may recall some of the main takeaways from the cancer heatmap and distributions: the West has some of the lowest cancer rate counties while Kentucky, Nebraska, and portions of the Northeast have high rate counties. Union County, FL does not any powerplants despite its extremely high cancer rate. 

Explore the distriubtion of powerplants using this heatmap. In particular, take a look at Southern California and Kentucky. Flip back and forth between the heatmaps to see where there are large differences.

* See information for individual powerplants or counties by <u>clicking on them</u>. Counties missing the cancer rate variable appear as grey on the heatmap. If there are many markers in an area of the map, they will be clustered into a circle with a number. To uncluster them, <u>click on the number</u> or <u> scroll with your mouse wheel</u> to zoom in where there are fewer in that area.
* Visually compare the relationship between the number of powerplants, energy capacity (MW), and cancer rates by changing the heatmap with the <u>radio buttons on the top right of the map</u> 
* To show/hide the location of individual powerplants, <u>check/uncheck the "Powerplant Markers" box</u>. 
* Energy is not generated with equal levels of pollution. Investigate categories of the energy sector to see if some types have more of a relationship with cancer than others. Two aggregations of plant type are set up: carbon-based powerplants (petcoke, coal, oil and natural gas) and renewable powerplants (biomass, geothermal, hydro, nuclear, solar, wind). To change powerplant type and see the new map, <u>select</u> the powerplant type in the "Choose Powerplant Type" box, then <u>click</u> the "Reset Map" button.
<br>

```{r}
fluidRow(div(style="display: inline-block;vertical-align:top; width: 170px;",selectizeInput("choose_plant_type","Choose Powerplant Type",choices = list('All','Carbon','Renewable',
  'Solar','Gas','Oil','Wind','Hydro','Coal','Biomass','Waste','Cogeneration','Storage','Geothermal','Nuclear','Petcoke','Other'),
  selected = list(
  'All'), options = list(`virtualScroll` = 6))),
  div(style="display: inline-block;vertical-align:top; width: 170px;",actionButton("clear_powerplant_map", "Reset Map")),
  align="center")
```


### Open Exploration: Predictors of Cancer Rates {data-commentary-width=400}

```{r, eval = TRUE}
fillRow(leafletOutput("cancer_map"),plotlyOutput("cancer_plotly"), flex = c(7,4))


output$cancer_map <- renderLeaflet({
  leaflet(data = map_data) %>%
  # Base groups
  addTiles() %>%
  setView(lng = -105, lat = 35, zoom = 3) %>% 
  addPolygons(fillColor = ~pal_cancer(cancer_per100k), 
              fillOpacity = 0.8, 
              color = "#BDBDC3", 
              weight = 1,
              popup = paste0("<strong>County: </strong>", 
                                                    map_data$county, ", ", map_data$state,
                                                    "<br><strong>Cancer/100k: </strong>", 
                                                    map_data$cancer_per100k,
                                                    "<br><strong>5 Yr. Cancer Trend: </strong>", 
                                                    map_data$trend5yr,
                                                    "<br><strong>Avg. Annual Cancer Count: </strong>", 
                                                    map_data$avg_annual_count
                             ),
              layerId = ~GEOID,
              group="Cancer Rate/100k") %>% 
    addLegend(position = "bottomright",
                pal = pal_cancer,
                values  = map_data$cancer_per100k,
                group = "Cancer Rate/100k",
                title = "Cancer Rate/100k",
                layerId = "cancer_legend",
                labFormat = labelFormat(digits=1))
})

output$cancer_plotly <- renderPlotly({
  react_list$df_cancer_map <- dataInBounds()
  temp <- as.data.frame(react_list$df_cancer_map) %>% arrange(GEOID) #%>% filter(!is.na(cancer_per100k)) %>% filter(!is.na(trend5yr))
  var_x <- react_list$cancer_var_x
  var_y <- react_list$cancer_var_y
  df_plot <- temp[!is.na(temp[[var_x]]),]
  df_plot <- df_plot[!is.na(df_plot[[var_y]]),]
  react_list$df_cancer <- df_plot

  # lm_fit <- lm(df_plot[[var_y]] ~ df_plot[[var_x]])
  # print(lm_fit)
  # print(var_x)
  # print(length(df_plot[[var_x]]))
  # print(sum(is.na(df_plot[[var_x]])))
  # print(length(lm_fit %>% fitted()))
  # 
  react_list$plotly_plot_made <- TRUE
  plot_ly(data = df_plot,
                      x = df_plot[[var_x]], 
                      y = df_plot[[var_y]],
                      type = "scatter",
                      mode = "markers",
                      source="cancer_plotly",
                      name = "Data",
                      hoverinfo = "text",
                      hovertext = paste0("<b>Location: </b>", 
                          df_plot$county,", ",df_plot$state, 
                          "<br><b>Cancer/100k: </b>", 
                          df_plot$cancer_per100k)
                      ) %>%
    #add_trace(x = df_plot[[var_x]], y = fitted(lm_fit), mode = "lines") %>%
  layout(showlegend = TRUE,
        title = list(text = paste0("Relationship between <br>",var_y," and ",var_x)),
        xaxis = list(title = var_x),
        yaxis = list(title = var_y)
         )
  })
```

*** 

Now it's time to explore the potential relationships between cancer rates and environmental factors. 

* The scatterplot and map are fully linked. Find out where a county lives on the scatterplot by <u>clicking that county on the map</u>, which will make a red dot  appear at that point on the scatterplot. To find the map location of a point on the scatterplot, <u>click on the point in the scatterplot</u>, and a popup will appear at that county on the map.
* Decide the region you want to perform analysis on by <u>zooming and panning</u> around the map. The continental United States is set by default. Notice that the scatterplot will adjust based on your map movement. 
* Determine the variables you want to examine the relationship of by <u>choosing your X and Y variables</u> then <u>click</u> "Reset Variables" to update the scatterplot. 
* Make quick model fits by <u>choosing</u> your regression line type and </u>adjusting</u> the degrees of freedom slider (for non-lm reg.).

Quick conclusions from this board show that there are slightly positive relationships between summed site score and cancer per 100k. Many of the relationships are weak.

```{r}
# A reactive expression that returns the set of counties that are
# in bounds right now
dataInBounds <- reactive({
  if (is.null(input$cancer_map_bounds))
    return(map_data[FALSE,])
  bounds <- input$cancer_map_bounds
  latRng <- range(bounds$north, bounds$south)
  lngRng <- range(bounds$east, bounds$west)
  
  subset(map_data,
    latitude >= latRng[1] & latitude <= latRng[2] &
      longitude >= lngRng[1] & longitude <= lngRng[2])
})

observeEvent(input$change_vars_button,{
  message(paste("explore: variables changed. xvar:,",input$cancer_var_x,", yvar:",input$cancer_var_y,"~~",Sys.time()))
  react_list$cancer_var_x <- input$cancer_var_x
  react_list$cancer_var_y <- input$cancer_var_y
})

observeEvent(input$cancer_map_shape_click, { 
  
    #print(paste("[",unlist(input$TraceMapping),"]"))
    if (react_list$num_traces_plotly_cancer == 1){
      plotlyProxy("cancer_plotly", session) %>%
        plotlyProxyInvoke("deleteTraces", 1)
    # traces <- matrix(input$TraceMapping, ncol = 2, byrow = TRUE)
    # indices <- as.integer(traces[traces[, 1] == react_list$past_point, 2])
    # 
    #   plotlyProxy("cancer_plotly", session) %>%
    #      plotlyProxyInvoke("deleteTraces", indices)
    }
    


  df_cancer_sub <- react_list$df_cancer %>% filter(GEOID %in% c(input$cancer_map_shape_click$id))
  cancer_var_x <- react_list$cancer_var_x
  cancer_var_y <- react_list$cancer_var_y
  message(paste0('explore: map click: FIPS ID: ',input$cancer_map_shape_click$id,', x var: ',df_cancer_sub[[cancer_var_x]],', y var: ',df_cancer_sub[[cancer_var_y]]),"~~",Sys.time())
  #print(str(df_cancer_sub[[cancer_var_y]]))
  #react_list$past_point <- paste0(df_cancer_sub$county,', ',df_cancer_sub$state)[1]
  if (!identical(df_cancer_sub[[cancer_var_y]], numeric(0))){
    plotlyProxy("cancer_plotly", session) %>%
    plotlyProxyInvoke("addTraces", list( 
                                      x = list(df_cancer_sub[[cancer_var_x]],NA),
                                      y = list(df_cancer_sub[[cancer_var_y]],NA),
                                      type = 'scatter',
                                      mode = 'markers',
                                      name = paste0(df_cancer_sub$county,', ',df_cancer_sub$state)[1],
                                      marker = list(size = 12.5,
                                                    color = 'rgba(255,51,51,0.8)',
                                                    line = list(color = 'rgba(255, 0, 0, .7)',
                                                              width = 2))
          )
    )
    react_list$num_traces_plotly_cancer <- 1
  }
})


observeEvent({event_data("plotly_click", source="cancer_plotly")}, {
    # get clicked point
    click_data <- event_data("plotly_click", source="cancer_plotly")
    test_df <<- react_list$df_cancer
    shape_i = react_list$df_cancer[click_data[['pointNumber']] + 1,]
    offset = isolate((input$cancer_map_bounds$north - input$cancer_map_bounds$south) / (23 + 7 + (18 - input$cancer_map_zoom)^2 ))
    
    message(paste("explore: plotly click: location:",shape_i$county,shape_i$state),"~~",Sys.time())
    
    leafletProxy("cancer_map") %>% addPopups(lat = shape_i$latitude + offset, lng = shape_i$longitude, 
                                             paste0("<strong>County: </strong>", 
                                                    shape_i$county, ", ", shape_i$state,
                                                    "<br><strong>Cancer/100k: </strong>", 
                                                    shape_i$cancer_per100k,
                                                    "<br><strong>5 Yr. Cancer Trend: </strong>", 
                                                    shape_i$trend5yr,
                                                    "<br><strong>Avg. Annual Cancer Count: </strong>", 
                                                    shape_i$avg_annual_count
                             ))
  })


# # SEE PLOTLY CLICK DATA
# renderPrint({
#     message('clicked')
#     d <- event_data("plotly_click", source="cancer_plotly")
#     print(d)
#     if (!is.null(d)) d
#   })
#   
# renderPrint({
#   d <- event_data("plotly_click", source="cancer_plotly")
#   if (!is.null(d)){
#     shape_i = react_list$df_cancer[d[['pointNumber']] + 1,]
#     shape_i$county
#     message(shape_i$county)
#     message(d)
#   }
# })


observeEvent(input$clear_cancer_popup_button, {
    message(paste("explore map: clear popups","~~",Sys.time()))
    leafletProxy("cancer_map") %>% clearPopups()
})


# js <- "function(el, x, inputName){
#   var id = el.getAttribute('id');
#   var d3 = Plotly.d3;
#   $(document).on('shiny:inputchanged', function(event) {
#     if (event.name === 'cancer_map_shape_click') {
#       var out = [];
#       d3.select('#' + id + ' g.legend').selectAll('.traces').each(function(){
#         var trace = d3.select(this)[0][0].__data__[0].trace;
#         out.push([name=trace.name, index=trace.index]);
#       });
#       Shiny.setInputValue(inputName, out);
#     }
#   });
# }"


  
observeEvent(c(input$reg_line,
  input$fit_df),{
  req(react_list$plotly_plot_made == TRUE)
    
  print(input$reg_line)
  df_plot <- react_list$df_cancer
  var_x <- react_list$cancer_var_x
  var_y <- react_list$cancer_var_y
  
  try({
  if (input$reg_line == 'lm'){
    fit <- lm(df_plot[[var_y]] ~ df_plot[[var_x]])
    fit_name <- paste0(input$reg_line, ' fit')
  }
  else if (input$reg_line == 'polynomial'){
    fit <- lm(df_plot[[var_y]] ~ stats::poly(df_plot[[var_x]], degree = input$fit_df))
    fit_name <- paste0(input$reg_line, ' fit, df:',input$fit_df)
  }
  else if (input$reg_line == 'spline'){
    fit <- gam(df_plot[[var_y]] ~ gam::s(df_plot[[var_x]], df = input$fit_df))
    fit_name <- paste0(input$reg_line, ' fit, df:',input$fit_df)
  }  
  else if (input$reg_line == 'natural-spline'){
    fit <- gam(df_plot[[var_y]] ~ splines::ns(df_plot[[var_x]], df = input$fit_df))
    fit_name <- paste0(input$reg_line, ' fit, df:',input$fit_df)
  }  
  else if (input$reg_line == 'basis-spline'){
    fit <- gam(df_plot[[var_y]] ~ splines::bs(df_plot[[var_x]],df = input$fit_df))
    fit_name <- paste0(input$reg_line, ' fit, df:',input$fit_df)
  }  
  
  
  df_plot_fit <- as.data.frame(fitted(fit))
  names(df_plot_fit) <- 'y'
  df_plot_fit['x'] <- df_plot[[var_x]]
  
  # pred_test <- predict(fit,data = df_plot_fit)
  # react_list$mse <- sum((pred_test - df_plot[[var_y]])^2/nrow(pred_test), na.rm = TRUE) %>% round(2) %>% as.character()
  # 
  
  df_plot_fit <- df_plot_fit %>% filter(!duplicated(x)) %>% arrange(x)
  
  
    
  plotlyProxy("cancer_plotly", session) %>%
    plotlyProxyInvoke("addTraces", list(
                                      x = as.list(unlist(df_plot_fit$x)),
                                      y = as.list(unlist(df_plot_fit$y)),
                                      type = 'scatter',
                                      mode = 'lines',
                                      name = fit_name
                                      )
          )
  message(paste("explore: regression line added. reg type:",input$reg_lin,"df:",input$fit_df,"~~",Sys.time()))
  })
})

observeEvent(input$clear_fits,{
       for( i in seq(1,10)){
         plotlyProxy("cancer_plotly", session) %>%
          plotlyProxyInvoke("deleteTraces", array(1))}
  message(paste("explore: regression lines reset","~~",Sys.time()))
})

fluidRow(div(style="display: inline-block;vertical-align:top; width: 170px;",selectInput("cancer_var_x","Select X Variable",list(            "# Superfund Sites" = "num_sites",
                                                           "Summed Site Score" = "sum_site_score",
                                                           "Avg. Year Superfund Site Listed" = "avg_listing_year",
                                                           "# Powerplants - All" = "num_pp",
                                                           "Capacity (MW) - All" = "sum_capacity_mw",                                               
                                                           "# Powerplants - Carbon" = "pp_carbon",
                                                           "Capacity (MW) - Carbon" = "capacity_mw_carbon",                                               
                                                           "# Powerplants - Renewable" = "pp_renewable",
                                                           "Capacity (MW) - Renewable" = "capacity_mw_renewable",
                                                           "# Powerplants - Solar" = "pp_solar",
                                                           "Capacity (MW) - Solar" = "capacity_mw_solar",
                                                           "# Powerplants - Coal" = "pp_coal",
                                                           "Capacity (MW) - Coal" = "capacity_mw_coal",                                                         
                                                           "# Powerplants - Nuclear" = "pp_nuclear",
                                                           "Capacity (MW) - Nuclear" = "capacity_mw_nuclear",
                                                           "State" = "state",
                                                           "EPA Region" = "epa_region",
                                                           "Census Region" = "region",
                                                           "Census Division" = "division"
                                               ), selected = "sum_site_score")),

div(style="display: inline-block;vertical-align:top; width: 170px;",selectInput("cancer_var_y","Select Y Variable",list("Cancer Rate/100k" = "cancer_per100k",
                                               "5-yr Cancer Trend" = "trend5yr",
                                               "Avg. Annual Cancer Count" = "avg_annual_count"
                                               ), selected = "cancer_per100k")
), align = 'center')

fluidRow(div(style="display: inline-block;vertical-align:top; width: 150px;",selectInput("reg_line", "Add Regression Line", list("None" = "",
                                           "Linear Regression" = "lm",
                                           "Polynomial" = "polynomial",
                                           "Smoothing Spline" = "spline",
                                           "Natural Spline" = "natural-spline",
                                           "Basis Spline" = "basis-spline"), selected = '')), align = 'center') #

# output$mse_text <- renderText({
#   react_list$mse
# })

sliderInput("fit_df","Degrees of Freedom", value = 2, min = 1, max = 10, width = '80%')

fluidRow(actionButton("change_vars_button", "Reset Variables"),actionButton("clear_fits", "Clear Fits"),actionButton("clear_cancer_popup_button", "Clear Map"), align = 'center')
```


### Models and Conclusions

```{r}
tabsetPanel(type="tabs",
    tabPanel("Model Overview", 
    
tags$div(tags$i(tags$strong("Click through the small tabs"))," on this model storyboard to see how various model types perform in predicting cancer rates (cancer_per100k) and the varying importance of the predictors in producing that model fit. Since there were not any strong relationships in the exploration storyboard, further additve model fitting were replaced with various tree methods including decision tree, random forest, and gradient boosting models. As this is a study with potential public health interest, models with low interpretability are important so the factors affecting cancer rates can be identified, therefore models with low interpretability were not considered.",tags$br(),tags$br(),
         "The response variable is the age-adjusted cancer rate per 100k people (cancer_per100k).",tags$br(),tags$br(),
         "All models use 11 variables as predictors and are numeric unless otherwise indicated.",tags$ul(
tags$li("summed superfund site score (sum_site_score)"),
tags$li("number of superfund sites (num_sites)"),
tags$li("number of renewable powerplants (pp_renewable)"),
tags$li("number of carbon powerplants (pp_carbon)"),
tags$li("number of total powerplants (num_pp)"),
tags$li("total capacity MW (sum_capacity_mw)"),
tags$li("capacity for renewable powerplants (capacity_mw_renewable)"),
tags$li("capacity for carbon powerplants (capacity_mw_carbon)"),
tags$li("state as a multi-level factor (state)"),
tags$li("census region as a multi-level factor (region)"),
tags$li("EPA region as a multi-level factor (epa_region)"),
    ))),

tabPanel("Decision Tree Model",
         
   fillRow(
     htmlOutput("tree_model"),
     
          tags$div(style = 'overflow-y:scroll;height:600px;',tags$p("The decision tree model is shown on the main graph to the left. If the tree does not show up, follow the directions on bullet three to refresh the tree rendering."),
                  tags$ul(
                    tags$li("To see the most important nodes on the tree, ",tags$u("hover, click, zoom, and pan.")),
                    tags$li("View the stats on the terminal nodes (purple boxes) by ",tags$u("hovering over")," the node and ",tags$u("click")," rules to see the criteria for that terminal node. The cancer rates generally go from low to high as you go from the left to the right on the terminal nodes of the tree."),
                    tags$li("There are two different trees that are considered here: a full tree model with all 11 predictors and an 8 predictor model without any location information (state, region, epa_region). ", tags$u("Select the tree type below")," to see each tree type.")),
     
     selectInput("tree_choice","Select Tree Type", choices = list("Full Tree (11 Predictors)" = "tree_simple",
                                                                  "Tree without location var (8 Predictors)" = "tree_nolocation"), selected = "tree_simple"),
tags$p("Each Cp value for the trees was set to 0.03. The results for the full tree shows that state is clearly the strongest predictor, occupying many nodes of the tree. Other variables that come up are number of renewable powerplants, generating capacity for carbon plants, and the summed Superfund site score. These nodes deeper in the tree means that environmental effects are only important for certain states. For example, hovering over the pp_renewable node shows that having 3 or more renewable plants in AZ, CO, HI, NM, and NV raises cancer rate. All of the non-state variables see increases in the variable associated with higher cancer rates. It is good to see that generating capacity for carbon increases cancer rates over other types of energy generation.",tags$br(),tags$br(),
     "The 8 predictor tree has a root node for generating capacity of renewable energy. It there is at least 2.15 MW capacity then cancer rates are generally lower. The second node for lower renewable capacity is summed site score. And as we would expect higher site score is associated with higher cancer rates. In all cases sum site score that is higher leads to higher cancer rates in this tree.")
  ),flex = c(14,6)
 )
),
tabPanel("Random Forest Model",
          fillRow(plotlyOutput("forest_mse"),
                  plotOutput("forest_importance"),
                  tags$div(style = 'overflow-y:scroll;height:600px;',withTags(p("Random forest of various hyperparameters were considered on the plotly graph on the far left. 5-fold cross validation test mean-squared error (MSE) is used to compare the different models. ",u("Zoom and hover"), " around the plotly graph to see the results of the hyperparameter optimization.",br(),br(),"At ~100 trees, the CV test MSE levels out and no further test MSE improvement occurs. The chosen 'best' model is marked with a red triangle at ntree=100, mtry=4 with a test MSE=2305.1. There is no evidence that overfitting has occurred as the test MSE does not rise despite increasing tree numbers. The center graph shows predictors on the y axis, and the colors show the distribution of depth in the tree. Predictors that are more important will be closer to the root of the trees of the random forest. We see again that the state variable is the strongest indicator, with an average depth in the forest of 0.92. The colors on the bar for the state variable show the distribution of node locations among the 100 trees. The top three variables are the location factor variables state, epa_region, and region. This shows that there are significant regional effects to cancer rates.",br(),br(), "The second group of factors include a combination of environmental factors. Energy capacity (MW) shows up multiple times for sub-categories and for all powerplants. Summed Superfund site score also appears, showing that contamination has a role to play in cancer rates.")))
          
                  ,flex = c(3,4,3))

     ),
tabPanel("Gradient Boosting Model",
             fillRow(plotlyOutput("gbm_mse"),
                     plotlyOutput("gbm_importance"),
                     tags$div(style = 'overflow-y:scroll;height:600px;',withTags(p("Model fit using gradient boosted trees yielded slightly improved results compared to the random forest models. Hyperparameter grid optimization was performed to minimize 5-fold cross validated test mean-squared error (MSE).",u("Zoom and hover"), " around the plotly graph on the far left to examine the results.",br(),br(),
    "The best hyperparameter combination is found at the red triangle. The learning rate (shrinkage) becomes too quick at shrinkage=0.01, so the best learning rate is at shrinkage=0.0075. The interaction depth shows that larger depths have lower test MSEs more quickly, but that the larger depth overfit with the addition of too many trees. This leads to an optimal solution of trees=350 and depth=6. Up to 2500 trees were considered and no further improvement happened after tree=350. The best test MSE for the GBM is 2189.6",br(),br(),
    
    "The variable importance plot for the optimal GBM model shows that the state variable is the best at explaining cancer rate variation. The next three most important predictors are electricity capacity variables. Sum site score and the number of powerplants are minor contributors to this model."
                       
                       
                       
                       )))
                     ,flex = c(5,3,2))
             
   ),
tabPanel("Conclusions",
         withTags(p("This study identifies a large variation in the cancer rates for counties across the United States. While there are many potential causes for cancer, environmental factors are not the strongest correlates to cancer rates. When examining the stark difference in cancer rates between counties in Eastern Kentucky and Southwest Virginia, the models points not to environmental causes, such as pollution from powerplants, or environmental contamination, from Superfund sites, as the primary cause, but to state-specific factors. Just living in Kentucky means that cancer rates are going to be higher than almost anywhere else in the country. This relationship was seen in exploratory analysis as well. All of the decision tree models supported the finding that state residence is the most important factor for cancer rates by county, that superfund sites play a minor role in cancer rate variation, and that carbon-based powerplants seem to have more of an effect than renewable powerplants. Further research on this topic is necessary and would include the addition of more predictors for cancer including healthcare information, morbidities from other poor health diseases such as heart disease, as well as detailed water and air pollution data.",br(),br(),"Please see the appendix storyboard to see the raw data used in this project and brief data methods information.")))
)

#### DECISION TREE MODEL

  
output$tree_model <- renderUI({
  tree_choice <- input$tree_choice

  if (tree_choice == "tree_simple"){
    tree_url = 'https://andersonmonken.georgetown.domains/wp-content/uploads/2020/05/full_tree-1.html'
    
  }
  else if (tree_choice == "tree_nolocation"){
    tree_url = 'https://andersonmonken.georgetown.domains/wp-content/uploads/2020/05/nolocation_tree-1.html'
    
  }
  tags$iframe(src=tree_url, width = '100%', height = '700px', style="border: none") #
  
})

#output$tree_model <- renderVisNetwork({visTree(tree_models[['tree_simple']], main = "testa")})

#savePlotToFile('simple_tree.png')

#### RANDOM FOREST MODEL

decision_df <- readRDS('forestresult.rds')

plot_testerrorrandom <- ggplot(data = decision_df %>% mutate(mtry = as.factor(mtry)), aes(x = ntree, y = test_mse, color = mtry)) + 
  geom_point(data = data.frame(y = 2305.100, x = 100), aes(x = x, y = y), color = "red", size = 5, shape = 2) +
  geom_vline(xintercept = 100, linetype = 'dashed') + 
  geom_line(size = 1.1) +
  ylab("CV Test MSE") + 
  xlab("Number of Trees") + labs(color = 'mtry') + 
  ggtitle("Random Forest Hyperparameter Optimization") +
  scale_color_manual(values = c("4" = "blue", "6" = "goldenrod", "11" = "forestgreen"), labels = c("m = sqrt(p), 4", "m = p/2, 4","m = p, 11")) + ylim(2000,2800)
output$forest_mse <- renderPlotly({plot_testerrorrandom %>% ggplotly()})

output$forest_importance <- renderPlot({readRDS('forest_importance_plot.rds') + ggtitle("Best Random Forest Model (mtry=4, ntree=100)\nDistribution of minimal depth and its mean")},height = 550)

#### GBM MODEL
decision_df_gbm <- readRDS('gbmresult.rds')

my_colors = brewer.pal(n = 11, "RdBu")[c(1:4,8:11)] #there are 9, I exluded the two lighter hues

gbm_plot <- ggplot(data = decision_df_gbm %>% mutate(interaction.depth = as.factor(interaction.depth)), aes( x = ntree, y = test_mse, color =  interaction.depth)) + 
  geom_point(data = data.frame(y = 2189.572, x = 350), aes(x = x, y = y), color = "red", size = 5, shape = 2) +
  geom_line() + xlab("Number of Trees") + ylab("CV Test MSE")  + labs(color = "Depth") +
  ggtitle("Gradient Boosting Hyperparameter Optimization") + facet_wrap(~shrinkage, labeller = label_both) + scale_color_manual(values = my_colors) + ylim(2000,2800)

output$gbm_mse <- renderPlotly({gbm_plot %>% ggplotly()})

gbm_importance <- readRDS('gbm_importance_plot.rds')
output$gbm_importance <- renderPlotly({gbm_importance %>% ggplotly()})

```

### Appendix {data-commentary-width=400}

```{r echo=FALSE}

library(DT)

observeEvent(input$data_select,{
  if (input$data_select =='county'){
    react_list$data_show <- map_data_df
  }
  else if (input$data_select =='pp'){
    react_list$data_show <- pp_data
  }
  else if (input$data_select =='sf'){
    react_list$data_show <- superfund_data
  }
})

DT::dataTableOutput('data_table', height = '240px')
output$data_table = DT::renderDataTable(DT::datatable(react_list$data_show, selection = 'single', rownames = FALSE, extensions = 'Buttons', options = list("autoWidth"=TRUE, "scrollY"=TRUE,"scrollX"=TRUE,lengthMenu = c(5, 10, 25), pageLength = 5,
  ajax = list(
    serverSide = TRUE, processing = TRUE))) %>%
DT::formatStyle(names(react_list$data_show),lineHeight='80%') )

```

***

Explore the raw data used for this project. There are three data sources used with new features created by the author. To see the different datasets, <u>choose the dataset</u> from the "Select Dataset" box.

```{r}
#p("By default DT allows multiple row selection. Selected rows are...")
#renderPrint(input$irisTable_rows_selected)
selectInput("data_select", "Select Dataset", choices = list("County-level Data" = "county",
                                         "Powerplant Data" = "pp",
                                         "Superfund Data" = "sf"), selected = "county")
```

Web scraping performed using beautiful soup in Python. Data was processed using Pandas and Numpy libraries in Python using Jupyter Lab. Data passed to R using Pyarrow's feather format.

Dashboard created using shiny and flexdashboard. Maps were constructed using leaflet. Census bureau provided geospatial data for heatmap polygons. Scatterplot made in Plotly. Data tables made using datatable (DT). This project would not have been possible without stackoverflow and numerous other online resources to advise on oddly frustrating R to javascript issues.

R packages used: leaflet, shiny, shinyjs, flexdashboard, plotly, shinycssloaders, shinyWidgets, dplyr, stringr, RColorBrewer, htmlwidgets, gam, DT, tigris, feather, sp, rgeos

If you are interested in seeing the code for this project, contact aem303@georgetown.edu for a link to the GitHub project. Student name is on GitHub so I cannot share the link here.


